// Copyright (c) 2014 Belmont Technology Pty Ltd. All rights reserved.
package com.grahamlea.examples.rxjava.threading

import rx.lang.scala.schedulers.{IOScheduler, ComputationScheduler}

/**
 * Shows how observeOn() can be used at multiple points through a
 * flow to change the threads being used for different parts of
 * processing.
 *
 * Interestingly, on my machine, values are still dealt with
 * sequentially after being generated by the main thread, even
 * though processing is happening on two different threads. This
 * continues to be true even if the delay in the second map()
 * operation is significantly increased. This suggests to me that
 * the work in the first scheduler blocks waiting on the work in
 * the downstream scheduler before continuing.
 */
object Example04_ObserveOnGeneratorAndMapper extends App {

  val shiftedUp = generator.observeOn(IOScheduler()).map(shiftUp).debug("Shifted Up")

  val shiftedDown = shiftedUp.observeOn(ComputationScheduler()).map(shiftDown).debug("Shifted Down")

  shiftedDown.subscribe(debug("Received", _))

  // The built in Schedulers use daemon threads, so you need to make the main thread stick around or you won't see anything
  Thread.sleep(1000)
}
